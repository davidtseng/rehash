.\" Automatically generated by Pod::Man 4.11 (Pod::Simple 3.35)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Data 3"
.TH Data 3 "2020-06-20" "perl v5.26.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Slash::MODULE \- SHORT DESCRIPTION for Slash
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&        use Slash::Utility;
\&        # do not use this module directly
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\s-1LONG DESCRIPTION.\s0
.SH "EXPORTED FUNCTIONS"
.IX Header "EXPORTED FUNCTIONS"
.SS "emailValid(\s-1EMAIL\s0)"
.IX Subsection "emailValid(EMAIL)"
Returns true if email is valid, false otherwise.
.IP "Parameters" 4
.IX Item "Parameters"
.RS 4
.PD 0
.IP "\s-1EMAIL\s0" 4
.IX Item "EMAIL"
.PD
Email address to check.
.RE
.RS 4
.RE
.IP "Return value" 4
.IX Item "Return value"
True if email is valid, false otherwise.
.SS "issueAge(\s-1ISSUE\s0)"
.IX Subsection "issueAge(ISSUE)"
Returns the \*(L"age\*(R" in days of an issue, given in issue mode form: yyyymmdd.
.IP "Parameters" 4
.IX Item "Parameters"
.RS 4
.PD 0
.IP "\s-1ISSUE\s0" 4
.IX Item "ISSUE"
.PD
Which issue, in yyyymmdd form (matches /^\ed{8}$/)
.RE
.RS 4
.RE
.IP "Return value" 4
.IX Item "Return value"
Age in days of that issue (a decimal number).  Takes current user's
timezone into account.  Return value of 0 indicates error.
.SS "submitDomainAllowed(\s-1DOMAIN\s0)"
.IX Subsection "submitDomainAllowed(DOMAIN)"
Returns true if domain is allowed, false otherwise.
.IP "Parameters" 4
.IX Item "Parameters"
.RS 4
.PD 0
.IP "\s-1DOMAIN\s0" 4
.IX Item "DOMAIN"
.PD
host domain to check.
.RE
.RS 4
.RE
.IP "Return value" 4
.IX Item "Return value"
True if domain is valid, false otherwise.
.SS "\fBroot2abs()\fP"
.IX Subsection "root2abs()"
Convert \f(CW\*(C`rootdir\*(C'\fR to its absolute equivalent.  By default, \f(CW\*(C`rootdir\*(C'\fR is
protocol-inspecific (such as \*(L"//www.example.com\*(R") and for redirects needs
to be converted to its absolute form.  There is an \f(CW\*(C`absolutedir\*(C'\fR var, but
it is protocol-specific, and we want to inherit the protocol.  So if we're
connected over \s-1HTTPS,\s0 we use \s-1HTTPS,\s0 else we use \s-1HTTP.\s0
.IP "Return value" 4
.IX Item "Return value"
rootdir variable, converted to absolute with proper protocol.
.SS "\fBroundrand()\fP"
.IX Subsection "roundrand()"
Rounds a real value to an integer value, randomly, with the
two options weighted in linear proportion to the fractional
component.  E.g. 1.3 is 30% likely to round to 1, 70% to 2.
And \-4.9 is 90% likely to round to \-5, 10% to \-4.
.IP "Return value" 4
.IX Item "Return value"
Input value converted to integer.
.SS "\fBset_rootdir()\fP"
.IX Subsection "set_rootdir()"
Make sure all your rootdirs use the same scheme (even if that scheme is no
scheme), and absolutedir's scheme can still be section-specific, and we don't
need an extra var for rootdir/absolutedir.
.PP
In the future, even this behavior should perhaps be overridable (so
sites could have http for the main site, and https for sections, for
example).
.IP "Return value" 4
.IX Item "Return value"
rootdir variable, converted to proper scheme.
.SS "cleanRedirectUrl(\s-1URL\s0)"
.IX Subsection "cleanRedirectUrl(URL)"
Clean an untrusted \s-1URL\s0 for safe redirection.  We do not redirect URLs received
from outside Slash (such as in \f(CW$form\fR\->{returnto}) to arbitrary sites, only
to ourself.
.IP "Parameters" 4
.IX Item "Parameters"
.RS 4
.PD 0
.IP "\s-1URL\s0" 4
.IX Item "URL"
.PD
\&\s-1URL\s0 to clean.
.RE
.RS 4
.RE
.IP "Return value" 4
.IX Item "Return value"
Fixed \s-1URL.\s0
.SS "url2abs(\s-1URL\s0 [, \s-1BASE\s0])"
.IX Subsection "url2abs(URL [, BASE])"
Take \s-1URL\s0 and make it absolute.  It takes a \s-1URL,\s0
and adds base to the beginning if necessary, and
adds the protocol to the beginning if necessary, and
then uses \s-1URI\-\s0>\fBnew_abs()\fR to get the correct string.
.IP "Parameters" 4
.IX Item "Parameters"
.RS 4
.PD 0
.IP "\s-1URL\s0" 4
.IX Item "URL"
.PD
\&\s-1URL\s0 to make absolute.
.IP "\s-1BASE\s0" 4
.IX Item "BASE"
\&\s-1URL\s0 base.  If not provided, uses rootdir.
.RE
.RS 4
.RE
.IP "Return value" 4
.IX Item "Return value"
Fixed \s-1URL.\s0
.SS "formatDate(\s-1DATA\s0 [, \s-1COLUMN, AS, FORMAT\s0])"
.IX Subsection "formatDate(DATA [, COLUMN, AS, FORMAT])"
Converts dates from the database; takes an arrayref of rows.
.PP
This example would take the 1th element of each arrayref in \f(CW$data\fR, format it,
and put the result in the 2th element.
.PP
.Vb 1
\&        formatDate($data, 1, 2);
.Ve
.PP
This example would take the \*(L"foo\*(R" key of each hashref in \f(CW$data\fR, format it,
and put the result in the \*(L"bar\*(R" key.
.PP
.Vb 1
\&        formatDate($data, \*(Aqfoo\*(Aq, \*(Aqbar\*(Aq);
.Ve
.PP
The \f(CW\*(C`timeCalc\*(C'\fR function does the formatting.
.IP "Parameters" 4
.IX Item "Parameters"
.RS 4
.PD 0
.IP "\s-1DATA\s0" 4
.IX Item "DATA"
.PD
Data is either an arrayref of arrayrefs, or an arrayref of hashrefs.
Which it is will be determined by whether \s-1COLUMN\s0 is numeric or not.  If
it is numeric, then \s-1DATA\s0 will be assumed to be an arrayref of arrayrefs.
.IP "\s-1COLUMN\s0" 4
.IX Item "COLUMN"
The column to take the data from, to be translated.  If numeric, then
\&\s-1DATA\s0 will be taken to be an arrayref of arrayrefs.  Otherwise, the value
will be the hashref key.  Default value is \*(L"date\*(R".
.IP "\s-1AS\s0" 4
.IX Item "AS"
The column where to put the newly formatted data.  If \s-1COLUMN\s0 is numeric
and \s-1AS\s0 is not defined, then \s-1AS\s0 will be the same value as \s-1COLUMN.\s0  Otherwise,
the default value of \s-1AS\s0 is \*(L"time\*(R".
.IP "\s-1FORMAT\s0" 4
.IX Item "FORMAT"
Optional Date::Format format string.
.RE
.RS 4
.RE
.IP "Return value" 4
.IX Item "Return value"
True if successful, false if not.
.IP "Side effects" 4
.IX Item "Side effects"
Changes values in \s-1DATA.\s0
.IP "Dependencies" 4
.IX Item "Dependencies"
The \f(CW\*(C`timeCalc\*(C'\fR function.
.SS "timeCalc(\s-1DATE\s0 [, \s-1FORMAT, OFFSET\s0])"
.IX Subsection "timeCalc(DATE [, FORMAT, OFFSET])"
Format time strings using user's format preference.
.IP "Parameters" 4
.IX Item "Parameters"
.RS 4
.PD 0
.IP "\s-1DATE\s0" 4
.IX Item "DATE"
.PD
Raw date/time to format.
Supply a false value here to get the current date/time.
.IP "\s-1FORMAT\s0" 4
.IX Item "FORMAT"
Optional format to override user's format.
.IP "\s-1OFFSET\s0" 4
.IX Item "OFFSET"
Optional positive or negative integer for offset seconds from \s-1GMT,\s0
to override user's offset.
.RE
.RS 4
.RE
.IP "Return value" 4
.IX Item "Return value"
Formatted date string.
.IP "Dependencies" 4
.IX Item "Dependencies"
The 'atonish' and 'aton' template blocks.
.SS "\fBcreateLogToken()\fP"
.IX Subsection "createLogToken()"
Return new random 22\-character logtoken, composed of \ew chars.
.IP "Return value" 4
.IX Item "Return value"
Return a random password that matches /^\ew{22}$/.
.Sp
We're only pulling out 3 chars each time thru this loop, so we only
need (and trust) about 18 bits worth of randomness.  We re-seed srand
periodically to try to get more randomness into the mix (\*(L"it uses a
semirandom value supplied by the kernel (if it supports the /dev/urandom
device)\*(R", says the Camel book).  I don't think I'm doing anything
mathematically dumb to introduce any predictability into this, so it
should be fine, wasteful of a few microseconds perhaps, ugly perhaps, but
the 22\-char value it returns should have very close to 131 bits of
randomness.
.SS "\fBchangePassword()\fP"
.IX Subsection "changePassword()"
Return new random 8\-character password composed of 0..9, A..Z, a..z
(but not including possibly hard-to-read characters [0O1Iil]).
.IP "Return value" 4
.IX Item "Return value"
Random password.
.SS "encryptPassword(\s-1PASSWD\s0)"
.IX Subsection "encryptPassword(PASSWD)"
Encrypts given password, using the most recent salt (if any) in
Slash::Apache::User::PasswordSalt for the current virtual user.
Currently uses \s-1MD5,\s0 but could change in the future, so do not
depend on the implementation.
.IP "Parameters" 4
.IX Item "Parameters"
.RS 4
.PD 0
.IP "\s-1PASSWD\s0" 4
.IX Item "PASSWD"
.PD
Password to be encrypted.
.RE
.RS 4
.RE
.IP "Return value" 4
.IX Item "Return value"
Encrypted password.
.SS "comparePassword(\s-1PASSWD, MD5, ISPLAIN, ISENC\s0)"
.IX Subsection "comparePassword(PASSWD, MD5, ISPLAIN, ISENC)"
Given a password and an \s-1MD5\s0 hex string, compares the two to see if they
represent the same value.  To be precise:
.PP
If the password given is equal to the \s-1MD5\s0 string, it must already be
in \s-1MD5\s0 format and be correct, so return true
.PP
Otherwise, the password is assumed to be plaintext.  Each possible
salt-encryption of it (including the encryption with empty salt) is
compared against the \s-1MD5\s0 string.  True is returned if there is any
match.
.PP
If \s-1ISPLAIN\s0 is true, \s-1PASSWD\s0 is assumed to be plaintext, so the
(trivial equality) test against the encrypted \s-1MD5\s0 is not performed.
.PP
If \s-1ISENC\s0 is true, \s-1PASSWD\s0 is assumed to be already encrypted, so the
tests of salting and encrypting it are not performed.
.PP
(If neither is true, all tests are performed.  If both are true, no
tests are performed and 0 is returned.)
.IP "Parameters" 4
.IX Item "Parameters"
.RS 4
.PD 0
.IP "\s-1PASSWD\s0" 4
.IX Item "PASSWD"
.PD
Possibly-correct password, either plaintext or already\-MD5's,
to be checked.
.IP "\s-1MD5\s0" 4
.IX Item "MD5"
Encrypted correct password.
.RE
.RS 4
.RE
.IP "Return value" 4
.IX Item "Return value"
0 or 1.
.SS "stripByMode(\s-1STRING\s0 [, \s-1MODE, NO_WHITESPACE_FIX\s0])"
.IX Subsection "stripByMode(STRING [, MODE, NO_WHITESPACE_FIX])"
Private function.  Fixes up a string based on what the mode is.  This
function is no longer exported, use the \f(CW\*(C`strip_*\*(C'\fR functions instead.
.Sp
.RS 4
[ Should this be somewhat templatized, so they can customize
the little \s-1HTML\s0 bits? Same goes with related functions. \*(-- pudge ]
.Sp
Parameters
.IP "\s-1STRING\s0" 4
.IX Item "STRING"
The string to be manipulated.
.IP "\s-1MODE\s0" 4
.IX Item "MODE"
May be one of:
.IP "nohtml" 4
.IX Item "nohtml"
The default.  Just strips out \s-1HTML.\s0
.IP "literal" 4
.IX Item "literal"
Prints the text verbatim into \s-1HTML,\s0 which
means just converting < and > and & to their
\&\s-1HTML\s0 entities.  Also turns on \s-1NO_WHITESPACE_FIX.\s0
.IP "extrans" 4
.IX Item "extrans"
Similarly to 'literal', converts everything
to its \s-1HTML\s0 entity, but then formatting is
preserved by converting spaces to \s-1HTML\s0
space entities, and multiple newlines into \s-1BR\s0
tags.
.IP "code" 4
.IX Item "code"
Just like 'extrans' but wraps in \s-1CODE\s0 tags.
.IP "attribute" 4
.IX Item "attribute"
Attempts to format string to fit in as an \s-1HTML\s0
attribute, which means the same thing as 'literal',
but " marks are also converted to their \s-1HTML\s0 entity.
.IP "plaintext" 4
.IX Item "plaintext"
Similar to 'extrans', but does not translate < and >
and & first (so \f(CW\*(C`stripBadHtml\*(C'\fR is called first).
.IP "anchor" 4
.IX Item "anchor"
Removes \s-1ALL\s0 whitespace from inside the filter. It's
is indented for use (but not limited to) the removal
of white space from in side \s-1HREF\s0 anchor tags to 
prevent nasty browser artifacts from showing up in
the display. (Note: the value of \s-1NO_WHITESPACE_FIX\s0 
is ignored)
.IP "html (or anything else)" 4
.IX Item "html (or anything else)"
Just runs through \f(CW\*(C`stripBadHtml\*(C'\fR.
.IP "\s-1NO_WHITESPACE_FIX\s0" 4
.IX Item "NO_WHITESPACE_FIX"
A boolean that, if true, disables fixing of whitespace
problems.  A common exploit in these things is to
run a lot of characters together so the page will
stretch very wide.  If \s-1NO_WHITESPACE_FIX\s0 is false,
then space is inserted to prevent this (see \f(CW\*(C`breakHtml\*(C'\fR).
.RE
.RS 4
.Sp
Return value
.Sp
The manipulated string.
.RE
.SS "strip_anchor(\s-1STRING\s0 [, \s-1NO_WHITESPACE_FIX\s0])"
.IX Subsection "strip_anchor(STRING [, NO_WHITESPACE_FIX])"
.SS "strip_attribute(\s-1STRING\s0 [, \s-1NO_WHITESPACE_FIX\s0])"
.IX Subsection "strip_attribute(STRING [, NO_WHITESPACE_FIX])"
.SS "strip_code(\s-1STRING\s0 [, \s-1NO_WHITESPACE_FIX\s0])"
.IX Subsection "strip_code(STRING [, NO_WHITESPACE_FIX])"
.SS "strip_extrans(\s-1STRING\s0 [, \s-1NO_WHITESPACE_FIX\s0])"
.IX Subsection "strip_extrans(STRING [, NO_WHITESPACE_FIX])"
.SS "strip_html(\s-1STRING\s0 [, \s-1NO_WHITESPACE_FIX\s0])"
.IX Subsection "strip_html(STRING [, NO_WHITESPACE_FIX])"
.SS "strip_literal(\s-1STRING\s0 [, \s-1NO_WHITESPACE_FIX\s0])"
.IX Subsection "strip_literal(STRING [, NO_WHITESPACE_FIX])"
.SS "strip_nohtml(\s-1STRING\s0 [, \s-1NO_WHITESPACE_FIX\s0])"
.IX Subsection "strip_nohtml(STRING [, NO_WHITESPACE_FIX])"
.SS "strip_notags(\s-1STRING\s0 [, \s-1NO_WHITESPACE_FIX\s0])"
.IX Subsection "strip_notags(STRING [, NO_WHITESPACE_FIX])"
.SS "strip_plaintext(\s-1STRING\s0 [, \s-1NO_WHITESPACE_FIX\s0])"
.IX Subsection "strip_plaintext(STRING [, NO_WHITESPACE_FIX])"
.SS "strip_mode(\s-1STRING\s0 [, \s-1MODE, NO_WHITESPACE_FIX\s0])"
.IX Subsection "strip_mode(STRING [, MODE, NO_WHITESPACE_FIX])"
Wrapper for \f(CW\*(C`stripByMode\*(C'\fR.  \f(CW\*(C`strip_mode\*(C'\fR simply calls \f(CW\*(C`stripByMode\*(C'\fR
and has the same arguments, but \f(CW\*(C`strip_mode\*(C'\fR will only allow modes
with values greater than 0, that is, the user-supplied modes.  \f(CW\*(C`strip_mode\*(C'\fR
is only meant to be used for processing user-supplied modes, to prevent
the user from accessing other mode types.  For using specific modes instead
of user-supplied modes, use the function with that mode's name.
.PP
See \f(CW\*(C`stripByMode\*(C'\fR for details.
.SS "strip_paramattr(\s-1STRING\s0 [, \s-1NO_WHITESPACE_FIX\s0])"
.IX Subsection "strip_paramattr(STRING [, NO_WHITESPACE_FIX])"
.SS "strip_paramattr_nonhttp(\s-1STRING\s0 [, \s-1NO_WHITESPACE_FIX\s0])"
.IX Subsection "strip_paramattr_nonhttp(STRING [, NO_WHITESPACE_FIX])"
.SS "strip_urlattr(\s-1STRING\s0 [, \s-1NO_WHITESPACE_FIX\s0])"
.IX Subsection "strip_urlattr(STRING [, NO_WHITESPACE_FIX])"
Wrappers for strip_attribute(fixparam($param), \f(CW$no_whitespace_fix\fR) and
strip_attribute(fudgeurl($url), \f(CW$no_whitespace_fix\fR).
.PP
Note that http is a bit of a special case:  its parameters can be escaped
with \*(L"+\*(R" for \*(L" \*(R", instead of just \*(L"%20\*(R".  So strip_paramattr should
probably be renamed strip_paramattrhttp to best indicate that it is a
special case.  But because the special case is also the most common case,
with over 100 occurrences in the code, we leave it named strip_paramattr,
and create a new function strip_paramattr_nonhttp which must be used for
\&\s-1URI\s0 schemes which do not behave in that way.
.SS "stripBadHtml(\s-1STRING\s0)"
.IX Subsection "stripBadHtml(STRING)"
Private function.  Strips out \*(L"bad\*(R" \s-1HTML\s0 by removing unbalanced \s-1HTML\s0
tags and sending balanced tags through \f(CW\*(C`approveTag\*(C'\fR.  The \*(L"unbalanced\*(R"
checker is primitive; no \*(L"<\*(R" or \*(L">\*(R" tags will are allowed inside
tag attributes (such as <A NAME=\*(L">\*(R">), that breaks the tag.
Whitespace is inserted between adjacent tags, so \*(L"<\s-1BR\s0><\s-1BR\s0>\*(R"
becomes \*(L"<\s-1BR\s0> <\s-1BR\s0>\*(R".  And character references are routed
through \f(CW\*(C`approveCharref\*(C'\fR.
.IP "Parameters" 4
.IX Item "Parameters"
.RS 4
.PD 0
.IP "\s-1STRING\s0" 4
.IX Item "STRING"
.PD
String to be processed.
.RE
.RS 4
.RE
.IP "Return value" 4
.IX Item "Return value"
Processed string.
.IP "Dependencies" 4
.IX Item "Dependencies"
\&\f(CW\*(C`approveTag\*(C'\fR function, \f(CW\*(C`approveCharref\*(C'\fR function.
.SS "processCustomTagsPre(\s-1STRING\s0)"
.IX Subsection "processCustomTagsPre(STRING)"
.SS "processCustomTagsPost(\s-1STRING\s0)"
.IX Subsection "processCustomTagsPost(STRING)"
Private function.  It does processing of special custom tags (in Pre, \s-1ECODE\s0;
in Post, \s-1QUOTE\s0).
.IP "Parameters" 4
.IX Item "Parameters"
.RS 4
.PD 0
.IP "\s-1STRING\s0" 4
.IX Item "STRING"
.PD
String to be processed.
.RE
.RS 4
.RE
.IP "Return value" 4
.IX Item "Return value"
Processed string.
.IP "Dependencies" 4
.IX Item "Dependencies"
Pre is meant to be used before \f(CW\*(C`approveTag\*(C'\fR is called; Post after.
Both are called only from regular posting modes, \s-1HTML\s0 and \s-1PLAINTEXT.\s0
.SS "breakHtml(\s-1TEXT, MAX_WORD_LENGTH\s0)"
.IX Subsection "breakHtml(TEXT, MAX_WORD_LENGTH)"
Private function.  Break up long words in some text.  Will ignore the
contents of \s-1HTML\s0 tags.  Called from \f(CW\*(C`stripByMode\*(C'\fR functions \*(-- if
there are any \s-1HTML\s0 tags in the text, \f(CW\*(C`stripBadHtml\*(C'\fR will have been
called first.  Handles spaces before dot-words so as to best work around a
Microsoft bug.  This code largely contributed by Joe Groff <joe at pknet
dot com>.
.IP "Parameters" 4
.IX Item "Parameters"
.RS 4
.PD 0
.IP "\s-1TEXT\s0" 4
.IX Item "TEXT"
.PD
The text to be fixed.
.IP "\s-1MAX_WORD_LENGTH\s0" 4
.IX Item "MAX_WORD_LENGTH"
The maximum length of a word.  Default is 50 (breakhtml_wordlength in vars).
.RE
.RS 4
.RE
.IP "Return value" 4
.IX Item "Return value"
The text.
.SS "fixHref(\s-1URL\s0 [, \s-1ERROR\s0])"
.IX Subsection "fixHref(URL [, ERROR])"
Take a relative \s-1URL\s0 and fix it to some predefined set.
.PP
I don't really like this function much, it should be played with.
.IP "Parameters" 4
.IX Item "Parameters"
.RS 4
.PD 0
.IP "\s-1URL\s0" 4
.IX Item "URL"
.PD
Relative \s-1URL\s0 to manipulate.
.IP "\s-1ERROR\s0" 4
.IX Item "ERROR"
Boolean whether or not to return error number.
.RE
.RS 4
.RE
.IP "Return value" 4
.IX Item "Return value"
Undef if \s-1URL\s0 is not handled.  If it is handled and \s-1ERROR\s0 is false,
new \s-1URL\s0 is returned.  If it is handled and \s-1ERROR\s0 is true, \s-1URL\s0
and the error number are returned.
.IP "Dependencies" 4
.IX Item "Dependencies"
The fixhrefs section in the vars table, and some sort of table
(like 404\-main) for determining what the number means.
.SS "approveTag(\s-1TAG\s0)"
.IX Subsection "approveTag(TAG)"
Private function.  Checks to see if \s-1HTML\s0 tag is \s-1OK,\s0 and adjusts it as necessary.
.IP "Parameters" 4
.IX Item "Parameters"
.RS 4
.PD 0
.IP "\s-1TAG\s0" 4
.IX Item "TAG"
.PD
Tag to check.
.RE
.RS 4
.RE
.IP "Return value" 4
.IX Item "Return value"
Tag after processing.
.IP "Dependencies" 4
.IX Item "Dependencies"
Uses the \*(L"approvetags\*(R" variable in the vars table.  Passes URLs
in HREFs through \f(CW\*(C`fudgeurl\*(C'\fR.
.SS "approveCharref(\s-1CHARREF\s0)"
.IX Subsection "approveCharref(CHARREF)"
Private function.  Checks to see if a character reference (minus the
leading & and trailing ;) is \s-1OK.\s0  If so, returns the whole character
reference (including & and ;), and if not, returns the empty string.
See <http://www.w3.org/TR/html4/charset.html#h\-5.3> for definitions and
explanations of character references.
.IP "Parameters" 4
.IX Item "Parameters"
.RS 4
.PD 0
.IP "\s-1CHARREF\s0" 4
.IX Item "CHARREF"
.PD
\&\s-1HTML\s0 character reference to check.
.RE
.RS 4
.RE
.IP "Return value" 4
.IX Item "Return value"
Character reference after processing.
.IP "Dependencies" 4
.IX Item "Dependencies"
None.
.SS "fixparam(\s-1DATA\s0)"
.IX Subsection "fixparam(DATA)"
Prepares data to be a parameter in a \s-1URL.\s0  Such as:
.Sp
.Vb 1
\&        my $url = \*(Aqhttp://example.com/foo.pl?bar=\*(Aq . fixparam($data);
.Ve
.Sp
.RS 4
Parameters
.IP "\s-1DATA\s0" 4
.IX Item "DATA"
The data to be escaped.  \fB\s-1NOTE\s0\fR: space characters are encoded as \f(CW\*(C`+\*(C'\fR
instead of \f(CW%20\fR.  If you must have \f(CW%20\fR, perform an \f(CW\*(C`s/\e+/%20/g\*(C'\fR
on the result.  Note that this is designed for \s-1HTTP\s0 URIs, the most
common scheme;  for other schemes, refer to the comments documenting
strip_paramattr and strip_paramattr_nonhttp.
.RE
.RS 4
.Sp
Return value
.Sp
The escaped data.
.RE
.SS "fixurl(\s-1DATA\s0)"
.IX Subsection "fixurl(DATA)"
Prepares data to be a \s-1URL\s0 or in part of a \s-1URL.\s0  Such as:
.Sp
.Vb 1
\&        my $url = \*(Aqhttp://example.com/~\*(Aq . fixurl($data) . \*(Aq/\*(Aq;
.Ve
.Sp
.RS 4
Parameters
.IP "\s-1DATA\s0" 4
.IX Item "DATA"
The data to be escaped.
.RE
.RS 4
.Sp
Return value
.Sp
The escaped data.
.RE
.SS "fudgeurl(\s-1DATA\s0)"
.IX Subsection "fudgeurl(DATA)"
Prepares data to be a \s-1URL.\s0  Such as:
.Sp
.Vb 1
\&        my $url = fudgeurl($someurl);
.Ve
.Sp
.RS 4
Parameters
.IP "\s-1DATA\s0" 4
.IX Item "DATA"
The data to be escaped.
.RE
.RS 4
.Sp
Return value
.Sp
The escaped data.
.RE
.SS "chopEntity(\s-1STRING\s0)"
.IX Subsection "chopEntity(STRING)"
Chops a string to a specified length, without splitting in the middle
of an \s-1HTML\s0 entity or \s-1HTML\s0 tag (so we will err on the short side).
.IP "Parameters" 4
.IX Item "Parameters"
.RS 4
.PD 0
.IP "\s-1STRING\s0" 4
.IX Item "STRING"
.PD
String to be chomped.
.RE
.RS 4
.RE
.IP "Return value" 4
.IX Item "Return value"
Chomped string.
.SS "balanceTags(\s-1HTML\s0 [, \s-1OPTIONS\s0])"
.IX Subsection "balanceTags(HTML [, OPTIONS])"
Balances \s-1HTML\s0 tags; if tags are not closed, close them; if they are not
open, remove close tags; if they are in the wrong order, reorder them
(order of open tags determines order of close tags).
.IP "Parameters" 4
.IX Item "Parameters"
.RS 4
.PD 0
.IP "\s-1HTML\s0" 4
.IX Item "HTML"
.PD
The \s-1HTML\s0 to balance.
.IP "\s-1OPTIONS\s0" 4
.IX Item "OPTIONS"
A hashref for various options.
.RS 4
.IP "deep_nesting" 4
.IX Item "deep_nesting"
Integer for how deep to allow nesting indenting tags, 0 means no limit, 1 means
to use var (nesting_maxdepth).  Default is 0.
.IP "deep_su" 4
.IX Item "deep_su"
Integer for how deep to allow nesting sup/sub tags, 0 means no limit, 1 means
to use var (nest_su_maxdepth).  Default is 0.
.IP "length" 4
.IX Item "length"
A maximum length limit for the result.
.RE
.RS 4
.RE
.RE
.RS 4
.RE
.IP "Return value" 4
.IX Item "Return value"
The balanced \s-1HTML.\s0
.IP "Dependencies" 4
.IX Item "Dependencies"
The 'approvedtags' entry in the vars table.
.SS "parseDomainTags(\s-1HTML, RECOMMENDED, NOTAGS\s0)"
.IX Subsection "parseDomainTags(HTML, RECOMMENDED, NOTAGS)"
To be called before sending the \s-1HTML\s0 to the user for display.  Takes
\&\s-1HTML\s0 with domain tags (see \fBaddDomainTags()\fR) and parses out the tags,
if necessary.
.IP "Parameters" 4
.IX Item "Parameters"
.RS 4
.PD 0
.IP "\s-1HTML\s0" 4
.IX Item "HTML"
.PD
The \s-1HTML\s0 tagged with domains.
.IP "\s-1RECOMMENDED\s0" 4
.IX Item "RECOMMENDED"
Boolean for whether or not domain tags are recommended.  They are not
required, the user can choose to leave it up to us.
.IP "\s-1NOTAGS\s0" 4
.IX Item "NOTAGS"
Boolean overriding \s-1RECOMMENDED\s0; it strips out all domain tags if true.
.IP "\s-1NOTITLE\s0" 4
.IX Item "NOTITLE"
Boolean which strips out title attributes for links if true
.RE
.RS 4
.RE
.IP "Return value" 4
.IX Item "Return value"
The parsed \s-1HTML.\s0
.SS "parseSlashizedLinks(\s-1HTML\s0)"
.IX Subsection "parseSlashizedLinks(HTML)"
To be called before sending the \s-1HTML\s0 to the user for display.  Takes
\&\s-1HTML\s0 with slashized links (see \fBslashizedLinks()\fR) and converts them to
the appropriate \s-1HTML.\s0
.IP "Parameters" 4
.IX Item "Parameters"
.RS 4
.PD 0
.IP "\s-1HTML\s0" 4
.IX Item "HTML"
.PD
The \s-1HTML\s0 with slashized links.
.RE
.RS 4
.RE
.IP "Return value" 4
.IX Item "Return value"
The parsed \s-1HTML.\s0
.SS "addDomainTags(\s-1HTML\s0)"
.IX Subsection "addDomainTags(HTML)"
To be called only after \f(CW\*(C`balanceTags\*(C'\fR, or results are not guaranteed.
Munges \s-1HTML\s0 </a> tags into </a foo.com> tags, where
\&\*(L"foo.com\*(R" is the domain name of the link found in the opening <a>
tag.  Note that this is not proper \s-1HTML,\s0 and that \f(CW\*(C`dispComment\*(C'\fR knows
how properly to convert it back to proper \s-1HTML.\s0
.IP "Parameters" 4
.IX Item "Parameters"
.RS 4
.PD 0
.IP "\s-1HTML\s0" 4
.IX Item "HTML"
.PD
The \s-1HTML\s0 to tag with domains.
.RE
.RS 4
.RE
.IP "Return value" 4
.IX Item "Return value"
The tagged \s-1HTML.\s0
.SS "slashizeLinks(\s-1HTML\s0)"
.IX Subsection "slashizeLinks(HTML)"
Munges \s-1HTML\s0 <a> tags that point to specific types of links on
this Slash site (articles.pl, comments.pl, and articles .shtml pages)
into a special type of <a> tag.  Note that this is not proper
\&\s-1HTML,\s0 and that it will be converted back to proper \s-1HTML\s0 when the
story is displayed.
.IP "Parameters" 4
.IX Item "Parameters"
.RS 4
.PD 0
.IP "\s-1HTML\s0" 4
.IX Item "HTML"
.PD
The \s-1HTML\s0 to slashize links in.
.RE
.RS 4
.RE
.IP "Return value" 4
.IX Item "Return value"
The converted \s-1HTML.\s0
.SS "xmlencode_plain(\s-1TEXT\s0)"
.IX Subsection "xmlencode_plain(TEXT)"
Same as xmlencode(\s-1TEXT\s0), but does not encode for use in \s-1HTML.\s0  This is
currently \s-1ONLY\s0 for use for <link> elements.
.IP "Parameters" 4
.IX Item "Parameters"
.RS 4
.PD 0
.IP "\s-1TEXT\s0" 4
.IX Item "TEXT"
.PD
Whatever text it is you want to encode.
.RE
.RS 4
.RE
.IP "Return value" 4
.IX Item "Return value"
The encoded string.
.IP "Dependencies" 4
.IX Item "Dependencies"
\&\fBXML::Parser::Expat\fR\|(3).
.SS "xmlencode(\s-1TEXT\s0)"
.IX Subsection "xmlencode(TEXT)"
Encodes / escapes a string for putting into \s-1XML.\s0
The text goes through three phases: we first convert
all \*(L"&\*(R" that are not part of an entity to \*(L"&amp;\*(R"; then
we convert all \*(L"&\*(R", \*(L"<\*(R", and \*(L">\*(R" to their entities.
Then all characters that are not printable \s-1ASCII\s0 characters
(\e040 to \e176) are converted to their numeric entities
(such as \*(L"&#192;\*(R").
.PP
Note that this is basically encoding a string into valid
\&\s-1HTML,\s0 then escaping it for \s-1XML.\s0  When run through regular
\&\s-1XML\s0 unescaping, a valid \s-1HTML\s0 string should remain
(that is, the characters will be valid for \s-1HTML,\s0 while it
may not be syntactically correct).  You may use something
like \f(CW\*(C`HTML::Entities::decode_entities\*(C'\fR if you wish to get
the regular text.
.IP "Parameters" 4
.IX Item "Parameters"
.RS 4
.PD 0
.IP "\s-1TEXT\s0" 4
.IX Item "TEXT"
.PD
Whatever text it is you want to encode.
.RE
.RS 4
.RE
.IP "Return value" 4
.IX Item "Return value"
The encoded string.
.IP "Dependencies" 4
.IX Item "Dependencies"
\&\fBXML::Parser::Expat\fR\|(3).
.SS "xmldecode(\s-1TEXT\s0)"
.IX Subsection "xmldecode(TEXT)"
Decodes / unescapes an \s-1XML\s0 string.  It basically just
decodes the five entities used to encode \*(L"<\*(R", \*(L">\*(R", '\*(L"',
\&\*(R"'\*(L", and \*(R"&\*(L".  \*(R"&" is only decoded if it is not the start
of an entity.
.PP
This will decode the named, decimal numeric, or hex numeric
versions of the entities.
.PP
Note that while \f(CW\*(C`xmlencode\*(C'\fR will make sure the characters
in the string are proper \s-1HTML\s0 characters, \f(CW\*(C`xmldecode\*(C'\fR will
not take the extra step to get back the original non-HTML
text; we want to leave the text as \s-1OK\s0 to put directly into
\&\s-1HTML.\s0  You may use something like
\&\f(CW\*(C`HTML::Entities::decode_entities\*(C'\fR if you wish to get
the regular text.
.IP "Parameters" 4
.IX Item "Parameters"
.RS 4
.PD 0
.IP "\s-1TEXT\s0" 4
.IX Item "TEXT"
.PD
Whatever text it is you want to decode.
.RE
.RS 4
.RE
.IP "Return value" 4
.IX Item "Return value"
The decoded string.
.SS "vislenify (\s-1ID_OR_HASHREF\s0 [, \s-1LEN\s0])"
.IX Subsection "vislenify (ID_OR_HASHREF [, LEN])"
Given an \s-1MD5\s0 string such as an \s-1IPID\s0 or SubnetID, converts it to
the length as determined by the id_md5_vislength var.  If passed
a hashref, looks for any and all of the keys ipid, subnetid, and
md5id, and if found, adds the same keys with _vis appended and
shortened values.  If passed an arrayref, it must be an arrayref
of hashrefs, and does the above for each hashref.
.IP "Parameters" 4
.IX Item "Parameters"
.RS 4
.PD 0
.IP "\s-1ID_OR_HASHREF\s0" 4
.IX Item "ID_OR_HASHREF"
.PD
Either a 32\-char \s-1MD5 ID\s0 string, or a hashref as described above.
.IP "\s-1LEN\s0" 4
.IX Item "LEN"
Usually not necessary;  if present, overrides the var id_md5_vislength.
.RE
.RS 4
.RE
.IP "Return value" 4
.IX Item "Return value"
If scalar \s-1ID\s0 passed in, returns new value.  If hashref passed in,
it is modified in place.
.SS "ellipsify (\s-1TEXT\s0 [, \s-1LEN\s0])"
.IX Subsection "ellipsify (TEXT [, LEN])"
Given any text, makes sure it's not too long by shrinking its
length to at most \s-1LEN,\s0 putting an ellipse in the middle.  If the
\&\s-1LEN\s0 is too short to allow an ellipse in the middle, it just does
an ellipse at the end, or in the worst case, a substr.
.IP "Parameters" 4
.IX Item "Parameters"
.RS 4
.PD 0
.IP "\s-1TEXT\s0" 4
.IX Item "TEXT"
.PD
Any text.
.IP "\s-1LEN\s0" 4
.IX Item "LEN"
Usually not necessary;  if present, overrides the var
comments_max_email_len (email is what this function was designed to
work on).
.RE
.RS 4
.RE
.IP "Return value" 4
.IX Item "Return value"
New value.
.SS "getArmoredEmail (\s-1UID\s0)"
.IX Subsection "getArmoredEmail (UID)"
Returns a Spam Armored email address for the user associated with the
given \s-1UID.\s0
.PP
This routine \s-1DOES NOT\s0 save its results back to the user record. This is
the responsibility of the calling routine.
.IP "Parameters" 4
.IX Item "Parameters"
.RS 4
.PD 0
.IP "\s-1UID\s0" 4
.IX Item "UID"
.PD
The user's \s-1ID\s0 whose email address you wish to randomize.
.RE
.RS 4
.RE
.IP "Return value" 4
.IX Item "Return value"
The email address, if successful.
.SS "getRandomWordFromDictFile (\s-1FILENAME, OPTIONS\s0)"
.IX Subsection "getRandomWordFromDictFile (FILENAME, OPTIONS)"
Pulls a random word from a dictionary file on disk (e.g. /usr/dict/words)
based on certain parameters.
.IP "Parameters" 4
.IX Item "Parameters"
.RS 4
.PD 0
.IP "\s-1FILENAME\s0" 4
.IX Item "FILENAME"
.PD
The name of the disk file to read from.
.RE
.RS 4
.RE
.IP "\s-1OPTIONS\s0" 4
.IX Item "OPTIONS"
min_chars is the word length minimum, or 1 by default.
.Sp
max_chars is the word length maximum, or 99 by default.
.Sp
word_regex is the regex to match a word; by default this will include
all words of all-lowercase letters (e.g. no \*(L"O'Reilly\*(R") between the
min_chars and max_chars lengths.
.Sp
excl_regexes is an arrayref of regular expressions.  If any one of them
matches a word it will not be returned.
.IP "Return value" 4
.IX Item "Return value"
The word found.
.SS "commify(\s-1NUMBER\s0)"
.IX Subsection "commify(NUMBER)"
Returns the number with commas added, so 1234567890 becomes
1,234,567,890.
.IP "Parameters" 4
.IX Item "Parameters"
.RS 4
.PD 0
.IP "\s-1NUMBER\s0" 4
.IX Item "NUMBER"
.PD
A number.
.RE
.RS 4
.RE
.IP "Return value" 4
.IX Item "Return value"
Commified number.
.SS "grepn(list, value)"
.IX Subsection "grepn(list, value)"
Returns the 1\-based position of the first occurance of \f(CW$value\fR in @$list.
.PP
[ That is not actually the case at all! ]
.IP "Parameters" 4
.IX Item "Parameters"
.RS 4
.PD 0
.IP "@$list" 4
.IX Item "@$list"
.PD
A reference to the list in question.
.ie n .IP "$value" 4
.el .IP "\f(CW$value\fR" 4
.IX Item "$value"
The value you wish to search for.
.RE
.RS 4
.RE
.IP "Return value" 4
.IX Item "Return value"
The position in the list of the first occurance of \f(CW$value\fR or undef if \f(CW$value\fR
is not in the list. Please note that the returned list is a 1\-based value,
not a 0\-based value, like perl arrays.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
\&\fBSlash\fR\|(3), \fBSlash::Utility\fR\|(3).
.SH "POD ERRORS"
.IX Header "POD ERRORS"
Hey! \fBThe above document had some coding errors, which are explained below:\fR
.IP "Around line 1135:" 4
.IX Item "Around line 1135:"
You can't have =items (as at line 1140) unless the first thing after the =over is an =item
.IP "Around line 2547:" 4
.IX Item "Around line 2547:"
You can't have =items (as at line 2551) unless the first thing after the =over is an =item
.IP "Around line 2587:" 4
.IX Item "Around line 2587:"
You can't have =items (as at line 2591) unless the first thing after the =over is an =item
.IP "Around line 2629:" 4
.IX Item "Around line 2629:"
You can't have =items (as at line 2633) unless the first thing after the =over is an =item

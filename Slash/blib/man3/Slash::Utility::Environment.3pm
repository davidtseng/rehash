.\" Automatically generated by Pod::Man 4.11 (Pod::Simple 3.35)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Environment 3"
.TH Environment 3 "2020-06-28" "perl v5.26.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Slash::Utility::Environment \- SHORT DESCRIPTION for Slash
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&        use Slash::Utility;
\&        # do not use this module directly
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\s-1LONG DESCRIPTION.\s0
.SH "EXPORTED FUNCTIONS"
.IX Header "EXPORTED FUNCTIONS"
.SS "dbAvailable([\s-1TOKEN\s0])"
.IX Subsection "dbAvailable([TOKEN])"
Returns \s-1TRUE\s0 if (as usual) the \s-1DB\s0(s) are available for reading and
writing.  Returns \s-1FALSE\s0 if the \s-1DB\s0(s) are not available and should not
be accessed.  If a \s-1TOKEN\s0 is named, return \s-1FALSE\s0 if either the \s-1DB\s0(s)
required for that purpose are down or all DBs are down.  If no \s-1TOKEN\s0 is
named, return \s-1FALSE\s0 only if all DBs are down.
.PP
Whether or not the DBs are down is determined only by whether files exist
at /usr/local/slash/dboff or /usr/local/slash/dboff_TOKEN.  For best
results, admins will want to write their own db-angel scripts that detect
DBs having gone down and create one or more of those files.
.IP "Parameters" 4
.IX Item "Parameters"
.RS 4
.PD 0
.IP "\s-1TOKEN\s0" 4
.IX Item "TOKEN"
.PD
Name of the resource specifically being asked about, or the
empty string.
.RE
.RS 4
.RE
.IP "Return value" 4
.IX Item "Return value"
0 or 1.
.SS "getCurrentMenu([\s-1NAME\s0])"
.IX Subsection "getCurrentMenu([NAME])"
Returns the menu for the resource requested.
.IP "Parameters" 4
.IX Item "Parameters"
.RS 4
.PD 0
.IP "\s-1NAME\s0" 4
.IX Item "NAME"
.PD
Name of the menu that you want to fetch.  If not supplied,
menu named after active script will be used (i.e., the \*(L"users\*(R"
menu for \*(L"users.pl\*(R").
.RE
.RS 4
.RE
.IP "Return value" 4
.IX Item "Return value"
A reference to an array with the menu in it is returned.
.SS "getCurrentUser([\s-1MEMBER\s0])"
.IX Subsection "getCurrentUser([MEMBER])"
Returns the current authenticated user.
.IP "Parameters" 4
.IX Item "Parameters"
.RS 4
.PD 0
.IP "\s-1MEMBER\s0" 4
.IX Item "MEMBER"
.PD
A member from the users record to be returned.
.RE
.RS 4
.RE
.IP "Return value" 4
.IX Item "Return value"
A hash reference with the user information is returned unless \s-1VALUE\s0 is passed. If
\&\s-1MEMBER\s0 is passed in then only its value will be returned.
.SS "setCurrentUser(\s-1MEMBER, VALUE\s0)"
.IX Subsection "setCurrentUser(MEMBER, VALUE)"
Sets a value for the current user.  It will not be permanently stored.
.IP "Parameters" 4
.IX Item "Parameters"
.RS 4
.PD 0
.IP "\s-1MEMBER\s0" 4
.IX Item "MEMBER"
.PD
The member to store \s-1VALUE\s0 in.
.IP "\s-1VALUE\s0" 4
.IX Item "VALUE"
\&\s-1VALUE\s0 to be stored in the current user hash.
.RE
.RS 4
.RE
.IP "Return value" 4
.IX Item "Return value"
The passed value.
.SS "setCurrentForm(\s-1MEMBER, VALUE\s0)"
.IX Subsection "setCurrentForm(MEMBER, VALUE)"
Sets a value for the current user.  It will not be permanently stored.
.IP "Parameters" 4
.IX Item "Parameters"
.RS 4
.PD 0
.IP "\s-1MEMBER\s0" 4
.IX Item "MEMBER"
.PD
The member to store \s-1VALUE\s0 in.
.IP "\s-1VALUE\s0" 4
.IX Item "VALUE"
\&\s-1VALUE\s0 to be stored in the current user hash.
.RE
.RS 4
.RE
.IP "Return value" 4
.IX Item "Return value"
The passed value.
.SS "createCurrentUser(\s-1USER\s0)"
.IX Subsection "createCurrentUser(USER)"
Creates the current user.
.IP "Parameters" 4
.IX Item "Parameters"
.RS 4
.PD 0
.IP "\s-1USER\s0" 4
.IX Item "USER"
.PD
\&\s-1USER\s0 to be inserted into current user.
.RE
.RS 4
.RE
.IP "Return value" 4
.IX Item "Return value"
Returns no value.
.SS "getCurrentForm([\s-1MEMBER\s0])"
.IX Subsection "getCurrentForm([MEMBER])"
Returns the current form.
.IP "Parameters" 4
.IX Item "Parameters"
.RS 4
.PD 0
.IP "\s-1MEMBER\s0" 4
.IX Item "MEMBER"
.PD
A member from the forms record to be returned.
.RE
.RS 4
.RE
.IP "Return value" 4
.IX Item "Return value"
A hash reference with the form information is returned unless \s-1VALUE\s0 is passed.  If
\&\s-1MEMBER\s0 is passed in then only its value will be returned.
.SS "createCurrentForm(\s-1FORM\s0)"
.IX Subsection "createCurrentForm(FORM)"
Creates the current form.
.IP "Parameters" 4
.IX Item "Parameters"
.RS 4
.PD 0
.IP "\s-1FORM\s0" 4
.IX Item "FORM"
.PD
\&\s-1FORM\s0 to be inserted into current form.
.RE
.RS 4
.RE
.IP "Return value" 4
.IX Item "Return value"
Returns no value.
.SS "getCurrentCookie([\s-1MEMBER\s0])"
.IX Subsection "getCurrentCookie([MEMBER])"
Returns the current cookie.
.IP "Parameters" 4
.IX Item "Parameters"
.RS 4
.PD 0
.IP "\s-1MEMBER\s0" 4
.IX Item "MEMBER"
.PD
A member from the cookies record to be returned.
.RE
.RS 4
.RE
.IP "Return value" 4
.IX Item "Return value"
A hash reference with the cookie incookieation is returned
unless \s-1VALUE\s0 is passed.  If \s-1MEMBER\s0 is passed in then
only its value will be returned.
.SS "createCurrentCookie(\s-1COOKIE\s0)"
.IX Subsection "createCurrentCookie(COOKIE)"
Creates the current cookie.
.IP "Parameters" 4
.IX Item "Parameters"
.RS 4
.PD 0
.IP "\s-1COOKIE\s0" 4
.IX Item "COOKIE"
.PD
\&\s-1COOKIE\s0 to be inserted into current cookie.
.RE
.RS 4
.RE
.IP "Return value" 4
.IX Item "Return value"
Returns no value.
.SS "getCurrentSkin([\s-1MEMBER\s0])"
.IX Subsection "getCurrentSkin([MEMBER])"
Returns the current skin.
.IP "Parameters" 4
.IX Item "Parameters"
.RS 4
.PD 0
.IP "\s-1MEMBER\s0" 4
.IX Item "MEMBER"
.PD
A member (field) from the skin record.
.RE
.RS 4
.RE
.IP "Return value" 4
.IX Item "Return value"
A hash reference with the skin information is returned unless \s-1MEMBER\s0 is
passed. If \s-1MEMBER\s0 is passed in then only its value will be returned.
.SS "setCurrentSkin(\s-1HASH\s0)"
.IX Subsection "setCurrentSkin(HASH)"
Set up the current skin global, which will be returned by
\&\fBgetCurrentSkin()\fR, for both static scripts and under Apache.
.IP "Parameters" 4
.IX Item "Parameters"
.RS 4
.PD 0
.IP "\s-1ID\s0" 4
.IX Item "ID"
.PD
Numeric \s-1ID\s0 (skins.skid) or name (skins.name).
.RE
.RS 4
.RE
.IP "Return value" 4
.IX Item "Return value"
Returns no value.
.SS "getCurrentStatic([\s-1MEMBER\s0])"
.IX Subsection "getCurrentStatic([MEMBER])"
Returns the current static variables (or variable).
.IP "Parameters" 4
.IX Item "Parameters"
.RS 4
.PD 0
.IP "\s-1MEMBER\s0" 4
.IX Item "MEMBER"
.PD
A member from the static record to be returned.
.RE
.RS 4
.RE
.IP "Return value" 4
.IX Item "Return value"
A hash reference with the static information is returned unless \s-1MEMBER\s0 is passed. If
\&\s-1MEMBER\s0 is passed in then only its value will be returned.
.SS "createCurrentStatic(\s-1HASH\s0)"
.IX Subsection "createCurrentStatic(HASH)"
Creates the current static information for non Apache scripts.
.IP "Parameters" 4
.IX Item "Parameters"
.RS 4
.PD 0
.IP "\s-1HASH\s0" 4
.IX Item "HASH"
.PD
A hash that is to be used in scripts not running in Apache to simulate a
script running under Apache.
.RE
.RS 4
.RE
.IP "Return value" 4
.IX Item "Return value"
Returns no value.
.SS "createCurrentHostname(\s-1HOSTNAME\s0)"
.IX Subsection "createCurrentHostname(HOSTNAME)"
Allows you to set a host so that constants will behave properly.
( This is not true or never implemented as far as I know, Jamie 2009\-04:
\&\*(L"This is used as a key into %$static_site_constants so that a single
Apache process can serve multiple Slash sites.\*(R" )
.IP "Parameters" 4
.IX Item "Parameters"
.RS 4
.PD 0
.IP "\s-1HOSTNAME\s0" 4
.IX Item "HOSTNAME"
.PD
A name of a host to use to force constants to think it is being used by a host.
.RE
.RS 4
.RE
.IP "Return value" 4
.IX Item "Return value"
Returns no value.
.SS "getCurrentAnonymousCoward([\s-1MEMBER\s0])"
.IX Subsection "getCurrentAnonymousCoward([MEMBER])"
Returns the current anonymous corward (or value from that object).
.IP "Parameters" 4
.IX Item "Parameters"
.RS 4
.PD 0
.IP "\s-1MEMBER\s0" 4
.IX Item "MEMBER"
.PD
A member from the \s-1AC\s0 record to be returned.
.RE
.RS 4
.RE
.IP "Return value" 4
.IX Item "Return value"
If \s-1MEMBER,\s0 then that value is returned; else, the hash containing all
the \s-1AC\s0 info will be returned.
.SS "createCurrentAnonymousCoward(\s-1HASH\s0)"
.IX Subsection "createCurrentAnonymousCoward(HASH)"
Creates the current anonymous coward for non Apache scripts.
.IP "Parameters" 4
.IX Item "Parameters"
.RS 4
.PD 0
.IP "\s-1HASH\s0" 4
.IX Item "HASH"
.PD
A hash that is to be used in scripts not running in Apache to simulate a
script running under Apache.
.RE
.RS 4
.RE
.IP "Return value" 4
.IX Item "Return value"
Returns no value.
.SS "\fBgetCurrentVirtualUser()\fP"
.IX Subsection "getCurrentVirtualUser()"
Returns the current virtual user that the site is running under.
.IP "Return value" 4
.IX Item "Return value"
The current virtual user that the site is running under.
.SS "createCurrentVirtualUser(\s-1VIRTUAL_USER\s0)"
.IX Subsection "createCurrentVirtualUser(VIRTUAL_USER)"
Creates the current virtual user for non Apache scripts.
.IP "Parameters" 4
.IX Item "Parameters"
.RS 4
.PD 0
.IP "\s-1VIRTUAL_USER\s0" 4
.IX Item "VIRTUAL_USER"
.PD
The current virtual user that is to be used in scripts not running in Apache
to simulate a script running under Apache.
.RE
.RS 4
.RE
.IP "Return value" 4
.IX Item "Return value"
Returns no value.
.SS "\fBgetCurrentDB()\fP"
.IX Subsection "getCurrentDB()"
Returns the current Slash::DB object.
.IP "Return value" 4
.IX Item "Return value"
Returns the current Slash::DB object.
.SS "createCurrentDB(\s-1SLASHDB\s0)"
.IX Subsection "createCurrentDB(SLASHDB)"
Creates the current \s-1DB\s0 object for scripts not running under Apache.
.IP "Parameters" 4
.IX Item "Parameters"
.RS 4
.PD 0
.IP "\s-1SLASHDB\s0" 4
.IX Item "SLASHDB"
.PD
Pass in a Slash::DB object to be used for scripts not running
in Apache.
.RE
.RS 4
.RE
.IP "Return value" 4
.IX Item "Return value"
Returns no value.
.SS "isAnon(\s-1UID\s0)"
.IX Subsection "isAnon(UID)"
Tests to see if the uid passed in is an anonymous coward.
.IP "Parameters" 4
.IX Item "Parameters"
.RS 4
.PD 0
.IP "\s-1UID\s0" 4
.IX Item "UID"
.PD
Value \s-1UID.\s0
.RE
.RS 4
.RE
.IP "Return value" 4
.IX Item "Return value"
Returns true if the \s-1UID\s0 is an anonymous coward, otherwise false.
.SS "isAdmin(\s-1UID\s0)"
.IX Subsection "isAdmin(UID)"
Tests to see if the uid passed in is an admin.
.IP "Parameters" 4
.IX Item "Parameters"
.RS 4
.PD 0
.IP "\s-1UID\s0" 4
.IX Item "UID"
.PD
Value \s-1UID.\s0  Can also be standard \f(CW$user\fR hashref.
.RE
.RS 4
.RE
.IP "Return value" 4
.IX Item "Return value"
Returns true if the \s-1UID\s0 is an admin, otherwise false.
.SS "isSubscriber(\s-1USER\s0)"
.IX Subsection "isSubscriber(USER)"
Tests to see if the user passed in is a subscriber.
.IP "Parameters" 4
.IX Item "Parameters"
.RS 4
.PD 0
.IP "\s-1USER\s0" 4
.IX Item "USER"
.PD
User data hashref from \fBgetUser()\fR call.
.Sp
If you pass a \s-1UID\s0 instead of a \s-1USER,\s0 then the function will call \fBgetUser()\fR for you.
.RE
.RS 4
.RE
.IP "Return value" 4
.IX Item "Return value"
Returns true if the \s-1USER\s0 is a subscriber, otherwise false.  Also returns
true if the \f(CW\*(C`subscribe\*(C'\fR var is false (everyone is a subscriber if there
are no subscriptions), so check in your caller if you need subscriptions
turned on.
.SS "isModBanned(\s-1USER\s0)"
.IX Subsection "isModBanned(USER)"
Tests to see if the user passed in banned from moderation.
.IP "Parameters" 4
.IX Item "Parameters"
.RS 4
.PD 0
.IP "\s-1USER\s0" 4
.IX Item "USER"
.PD
User data hashref from \fBgetUser()\fR call.
.Sp
If you pass a \s-1UID\s0 instead of a \s-1USER,\s0 then the function will call \fBgetUser()\fR for you.
.RE
.RS 4
.RE
.IP "Return value" 4
.IX Item "Return value"
Returns true if the \s-1USER\s0 is mod banned, otherwise false.
.SS "getAnonId([\s-1FORMKEY\s0])"
.IX Subsection "getAnonId([FORMKEY])"
Returns a string of random alphanumeric characters.
.IP "Parameters" 4
.IX Item "Parameters"
.RS 4
.PD 0
.IP "\s-1NOPREFIX\s0" 4
.IX Item "NOPREFIX"
.PD
Don't prepend a \*(L"\-1\-\*(R" string. That prefix is no longer used anywhere in
the code, so basically everyplace this function is used passes in true
for noprefix.  All part of the slow evolution of the codebase!
.IP "\s-1COUNT\s0" 4
.IX Item "COUNT"
Number of characters (default 10).
.RE
.RS 4
.RE
.IP "Return value" 4
.IX Item "Return value"
A random value based on alphanumeric characters
.SS "bakeUserCookie(\s-1UID, VALUE\s0)"
.IX Subsection "bakeUserCookie(UID, VALUE)"
Bakes (creates) a user cookie from its ingredients (\s-1UID, VALUE\s0).
.PP
The cookie used to be hexified; it is no longer.  We can still read such
cookies, though, but we don't create them.
.IP "Parameters" 4
.IX Item "Parameters"
.RS 4
.PD 0
.IP "\s-1UID\s0" 4
.IX Item "UID"
.PD
User \s-1ID.\s0
.IP "\s-1VALUE\s0" 4
.IX Item "VALUE"
Cookie's value.  This used to be called 'passwd' but the value that gets
put into user cookies now isn't a password anymore.
.RE
.RS 4
.RE
.IP "Return value" 4
.IX Item "Return value"
Created cookie.
.SS "eatUserCookie(\s-1COOKIE\s0)"
.IX Subsection "eatUserCookie(COOKIE)"
Digests (parses) a user cookie, returning it to its original ingredients
(\s-1UID,\s0 value).
.PP
The cookie used to be hexified; it is no longer.  We can still read such
cookies, though.
.IP "Parameters" 4
.IX Item "Parameters"
.RS 4
.PD 0
.IP "\s-1COOKIE\s0" 4
.IX Item "COOKIE"
.PD
Cookie to be parsed.
.RE
.RS 4
.RE
.IP "Return value" 4
.IX Item "Return value"
The \s-1UID\s0 and value encoded in the cookie.
.SS "setCookie(\s-1NAME, VALUE, SESSION\s0)"
.IX Subsection "setCookie(NAME, VALUE, SESSION)"
Creates a cookie and places it into the outbound headers.  Can be
called multiple times to set multiple cookies.
.IP "Parameters" 4
.IX Item "Parameters"
.RS 4
.PD 0
.IP "\s-1NAME\s0" 4
.IX Item "NAME"
.PD
Name of the cookie.
.IP "\s-1VALUE\s0" 4
.IX Item "VALUE"
Value to be placed in the cookie.
.IP "\s-1SESSION\s0" 4
.IX Item "SESSION"
Flag to determine if the cookie should be a session cookie.  \*(L"1\*(R" means
yes, expire it after the current session.  \*(L"2\*(R" means to expire it
according to the login_temp_minutes var.  And a value that looks like
a session time, like \*(L"+24h\*(R", is passed along directly (in that case,
expires 24 hours from now).
.RE
.RS 4
.RE
.IP "Return value" 4
.IX Item "Return value"
No value is returned.
.SS "getPollVoterHash([\s-1UID\s0])"
.IX Subsection "getPollVoterHash([UID])"
.SS "getPublicLogToken([\s-1UID\s0])"
.IX Subsection "getPublicLogToken([UID])"
Just a wrapper around:
.PP
.Vb 1
\&        bakeUserCookie($uid, $slashdb\->getLogToken($uid, 1, 2));
.Ve
.PP
to get a public logtoken.  Uses current user's \s-1UID\s0 if none supplied.
.ie n .SS "userLogout($uid, $cookies, $options)"
.el .SS "userLogout($uid, \f(CW$cookies\fP, \f(CW$options\fP)"
.IX Subsection "userLogout($uid, $cookies, $options)"
Deletes the user's logtoken and cookie (logs them out).
Will accept (and modify) a \f(CW$cookies\fR hashref.
Returns the \s-1AC UID\s0 for use in the caller.
.SS "prepareUser(\s-1UID, FORM, URI\s0 [, \s-1COOKIES\s0])"
.IX Subsection "prepareUser(UID, FORM, URI [, COOKIES])"
This is called to initialize the user.  It is called from
Slash::Apache::User::handler, and from createEnvironment (so it
can set up a user in \*(L"command line\*(R" mode).  See those two functions
to see how to call this function in each kind of environment.
.IP "Parameters" 4
.IX Item "Parameters"
.RS 4
.PD 0
.IP "\s-1UID\s0" 4
.IX Item "UID"
.PD
The \s-1UID\s0 of the user.  Can be anonymous coward.  Will be anonymous
coward if uid is not defined.
.IP "\s-1FORM\s0" 4
.IX Item "FORM"
The form data (which may be the same data returned by getCurrentForm).
.IP "\s-1URI\s0" 4
.IX Item "URI"
The \s-1URI\s0 of the page the user is on.
.IP "\s-1COOKIES\s0" 4
.IX Item "COOKIES"
An Apache2::Cookie object (not used in \*(L"command line\*(R" mode).
.RE
.RS 4
.RE
.IP "Return value" 4
.IX Item "Return value"
The prepared user data.
.IP "Side effects" 4
.IX Item "Side effects"
Sets some cookies in Apache mode, sets currentPage (for templates) and
bunches of other user datum.  If the default values or the schema for
fields like karma_bonus or domaintags ever changes, such that writing
\&'undef' to delete a users_param row is no longer an acceptable
alternative to writing out the default value, then the code both here
and in users.pl save*() should be re-examined.
.SS "filter_params(\s-1PARAMS\s0)"
.IX Subsection "filter_params(PARAMS)"
This cleans up form data before it is used by the program.
.IP "Parameters" 4
.IX Item "Parameters"
.RS 4
.PD 0
.IP "\s-1PARAMS\s0" 4
.IX Item "PARAMS"
.PD
A hash of the parameters to clean up.
.RE
.RS 4
.RE
.IP "Return value" 4
.IX Item "Return value"
Hashref of cleaned-up data.
.SS "setUserDate(\s-1USER\s0)"
.IX Subsection "setUserDate(USER)"
Sets some date information for the user, including date format, time zone,
and time zone offset from \s-1GMT.\s0  This is a separate function because the
logic is a bit complex, and it needs to happen in two different places:
anonymous coward creation in the httpd creation, and each time a user is
prepared.
.IP "Parameters" 4
.IX Item "Parameters"
.RS 4
.PD 0
.IP "\s-1USER\s0" 4
.IX Item "USER"
.PD
The user hash reference.
.RE
.RS 4
.RE
.IP "Return value" 4
.IX Item "Return value"
None.
.SS "isDST(\s-1REGION\s0 [, \s-1USER, TIME, OFFSET\s0])"
.IX Subsection "isDST(REGION [, USER, TIME, OFFSET])"
Returns boolean for whether given time, for given user, is in Daylight
Savings Time.
.IP "Parameters" 4
.IX Item "Parameters"
.RS 4
.PD 0
.IP "\s-1REGION\s0" 4
.IX Item "REGION"
.PD
The name of the current \s-1DST\s0 region (e.g., America, Europe, Australia).
It must match the \f(CW\*(C`region\*(C'\fR column of the \f(CW\*(C`dst\*(C'\fR table.
.IP "\s-1USER\s0" 4
.IX Item "USER"
You will get better results if you pass in the \s-1USER,\s0 but it is optional.
.IP "\s-1TIME\s0" 4
.IX Item "TIME"
Time in seconds since beginning of epoch, in \s-1GMT\s0 (which is the default
for Unix).  Optional; default is current time if undefined.
.IP "\s-1OFFSET\s0" 4
.IX Item "OFFSET"
Offset of current timezone in seconds from \s-1GMT.\s0  Optional; default is
current user's \f(CW\*(C`off_set\*(C'\fR if undefined.
.RE
.RS 4
.RE
.IP "Return value" 4
.IX Item "Return value"
Boolean for whether we are currently in \s-1DST.\s0
.SS "getObject(\s-1CLASS_NAME\s0 [, \s-1VIRTUAL_USER, ARGS\s0]) =head2 getObject(\s-1CLASS_NAME\s0 [, \s-1OPTIONS, ARGS\s0])"
.IX Subsection "getObject(CLASS_NAME [, VIRTUAL_USER, ARGS]) =head2 getObject(CLASS_NAME [, OPTIONS, ARGS])"
Returns a object in \s-1CLASS_NAME,\s0 using the \fBnew()\fR constructor.  It passes
\&\s-1VIRTUAL_USER\s0 and \s-1ARGS\s0 to it, and then caches it by \s-1CLASS_NAME\s0 and \s-1VIRTUAL_USER.\s0
If the object for that \s-1CLASS_NAME/VIRTUAL_USER\s0 exists the second time through,
it will just return, without reinitializing (even if different \s-1ARGS\s0 are passed,
so don't do that; see \*(L"nocache\*(R" option).
.PP
In the second form, \s-1OPTIONS\s0 is a hashref.
.IP "Parameters" 4
.IX Item "Parameters"
.RS 4
.PD 0
.IP "\s-1CLASS_NAME\s0" 4
.IX Item "CLASS_NAME"
.PD
A class name to use in creating a object.  Only [\ew:] characters are allowed.
.IP "\s-1VIRTUAL_USER\s0" 4
.IX Item "VIRTUAL_USER"
Optional; will default to main Virtual User for site if not supplied.
Passed as second argument to the \fBnew()\fR constructor (after class name).
.IP "\s-1OPTIONS\s0" 4
.IX Item "OPTIONS"
Optional; several options are currently recognized.
.RS 4
.IP "virtual_user" 4
.IX Item "virtual_user"
String.  This is handled the same was as the first form, as though using
\&\s-1VIRTUAL_USER,\s0 but allows for passing other options too.  Overrides \*(L"db_type\*(R"
option.
.IP "db_type" 4
.IX Item "db_type"
String.  There are types of DBs (reader, writer, search, log), and there may be more
than one \s-1DB\s0 of each type.  By passing a db_type instead of a virtual_user, you
request any \s-1DB\s0 of that type, instead of a specific \s-1DB.\s0
.Sp
If neither \*(L"virtual_user\*(R" or \*(L"db_type\*(R" is passed, then the function will do a
lookup of the class for what type of \s-1DB\s0 handle it wants, and then pick one
\&\s-1DB\s0 at random that is of that type.
.IP "nocache" 4
.IX Item "nocache"
Boolean.  Get a new object, not a cached one.  Also won't cache the resulting object
for future calls.
.IP "timeout" 4
.IX Item "timeout"
Boolean.  Will time out after ''timeout'' seconds in trying to get the object.
.RE
.RS 4
.RE
.IP "\s-1ARGS\s0" 4
.IX Item "ARGS"
Any other arguments to be passed to the object's constructor.
.RE
.RS 4
.RE
.IP "Return value" 4
.IX Item "Return value"
An object, unless object cannot be gotten; then undef.
.SS "\fBerrorLog()\fP"
.IX Subsection "errorLog()"
Generates an error that either goes to Apache's error log
or to \s-1STDERR.\s0 The error consists of the package and
and filename the error was generated and the same information
on the previous caller.
.IP "Return value" 4
.IX Item "Return value"
Returns 0;
.SS "writeLog(\s-1DATA\s0)"
.IX Subsection "writeLog(DATA)"
Places optional data in the accesslog.
.SS "createEnvironment([\s-1VIRTUAL_USER\s0])"
.IX Subsection "createEnvironment([VIRTUAL_USER])"
Places data into the request records notes table. The two keys
it uses are \s-1SLASH_LOG_OPERATION\s0 and \s-1SLASH_LOG_DATA.\s0
.PP
This does \s-1NOT\s0 create the current skin, which all scripts are
expected to set themselves with \fBsetCurrentSkin()\fR.  For doing
so, the function \fBdetermineCurrentSkin()\fR may be helpful.
.IP "Parameters" 4
.IX Item "Parameters"
.RS 4
.PD 0
.IP "\s-1VIRTUAL_USER\s0" 4
.IX Item "VIRTUAL_USER"
.PD
Optional.  You can pass in a virtual user that will be used instead of
parsing \f(CW@ARGV\fR.
.RE
.RS 4
.RE
.IP "Return value" 4
.IX Item "Return value"
No value is returned.
.SS "determineCurrentSkin"
.IX Subsection "determineCurrentSkin"
Returns what the skid of the current skin \*(L"should\*(R" be.  If we are in
an Apache request, this is done by examining the \s-1URL,\s0 principally the
hostname but perhaps also the path and the form.  If not, this is done
by examining the form (which was passed on the command line).
.IP "Parameters" 4
.IX Item "Parameters"
.RS 4
.PD 0
.IP "Return value" 4
.IX Item "Return value"
.PD
Numeric skid of the current skin.
.RE
.RS 4
.RE
.SS "get_srcids"
.IX Subsection "get_srcids"
Converts an \s-1IP\s0 address and/or user id to a hashref containing one or
more srcids.
.IP "Parameters" 4
.IX Item "Parameters"
.RS 4
.PD 0
.IP "\s-1DATA\s0" 4
.IX Item "DATA"
.PD
A hashref containing one or more of two possible fields:  (1) \*(L"uid\*(R",
whose value is a user id;  and/or (2) \*(L"ip\*(R", whose value is a text string
representing an IPv4 or IPv6 address in string form, or a false value
which means to use the current Apache connection's remote_ip if invoked 
within Apache, or the dummy value \*(L"0.0.0.0\*(R" otherwise.
.IP "\s-1OPTIONS\s0" 4
.IX Item "OPTIONS"
An optional hashref containing zero or more options.  The option
\&'no_md5', if its field is any true value, ensures that IPs encoded into
the returned hashref, while still masked, are not \s-1MD5\s0'd but kept in string
\&\*(L"1.2.3.4\*(R" form.
.Sp
The option 'masks' can be a scalar containing a single value or an
arrayref containing multiple values.  By default, only two masked-off
values of an \s-1IP\s0 are encoded:  a 32\-bit and a 24\-bit mask (the \s-1IP\s0 itself
and its Class C subnet).  Any additional values between 1 and 32 may be
passed in in 'masks' and those additional mask sizes will also be
calculated and encoded in the returned hashref.
.Sp
For IPv6 addresses, the default masked off values are 64\-bit, 56\-bit,
and 48\-bit. Masking an individual IPv6 address is relatively useless
due to things like IPv6 privacy extensions
.Sp
The option 'return_only' will change the returned value from a hashref
with multiple fields into an array which contains the values of one or
more of what those fields would have been.  The value(s) of 'return_only'
can be: (1) the string \*(L"uid\*(R" to return just the uid, (2) an integer
between 1 and 32 (which will be implied into the 'masks' option as well),
(3) one of the three strings \*(L"ipid\*(R", \*(L"subnetid\*(R", or \*(L"classbid\*(R" which
are the equivalent of the integers 32, 24, and 16 respectively, or (4)
the string \*(L"cookie_location\*(R", which will be replaced by the value of
the var 'cookie_location'.
.RE
.RS 4
.RE
.IP "Return value" 4
.IX Item "Return value"
The uid and/or ip converted to an encoded hashref.  If a uid was passed
in, the field \*(L"uid\*(R" stores the converted uid (which happens to be the
uid itself).  If an ip was passed in, there will be one or more fields
whose names are integer values between 1 and 32 and whose values are
64\-bit (16\-char) lowercase hex strings with the encoded values of the ip.
There will also be the convenience field \*(L"ip\*(R" set which contains the
original ip value passed in.  (But see \s-1OPTIONS:\s0  if return_only is set,
only one of the fields of the hashref will be returned.)
.SS "get_srcid_prependbyte"
.IX Subsection "get_srcid_prependbyte"
This returns the two-character hex code that should be prepended
to a 14\-character hex value to create the 16\-character hex value
representing either a user \s-1ID\s0 or an encoded \s-1IP\s0 address \s-1MD5.\s0
.IP "Parameters" 4
.IX Item "Parameters"
.RS 4
.PD 0
.IP "\s-1PARAMS\s0" 4
.IX Item "PARAMS"
.PD
A hash of the parameters.  'type' is a required parameter; its only
defined values so far are 'ipid', indicating an encoded \s-1IP\s0 address of
some type, or 'uid', indicating a user \s-1ID.\s0  Other values may be
possible in future.
.RS 4
.Sp
.RS 4
If 'type' eq 'ipid', the parameter 'mask' must be present, a number
from 1 to 32 indicating how many bits will be present.  For example,
a 24 here would have the same meaning as in '192.168.0.0/24',
signifying the address is a Class C.
.RE
.RE
.RS 4
.Sp
.RS 4
If 'type' eq 'uid', no other parameters are necessary.
.RE
.RE
.RS 4
.RE
.RE
.RS 4
.RE
.IP "Return value" 4
.IX Item "Return value"
Two-character hex code to prepend.  The bit values of this code are
currently defined as follows:
.RS 4
.Sp
.RS 4
bits 0\-2 (MSBs): 0b000=uid; 0b001=IPv4 ipid; other values reserved
for future use.
.Sp
bits 3\-7 (LSBs): if uid, all 0; if IPv4 ipid, 32 minus the mask
size (so 0b00000 indicates a mask size of 32, 0b01000 24, etc.)
.Sp
if IPv6 ipid6, 128 minus the mask size like IPv4
.RE
.RE
.RS 4
.Sp
Thus the most commonly returned values will be: \*(L"00\*(R" = uid,
\&\*(L"20\*(R" = ipid, \*(L"28\*(R" = subnetid, \*(L"30\*(R" = classbid.
.RE
.SS "get_srcid_sql_in"
.IX Subsection "get_srcid_sql_in"
Pass this a srcid, either in decimal form (which is what uids will
typically be in) or as a 64\-bit (16\-char) hex string, and it will return
an \s-1SQL\s0 function or value which can be used as part of a test against
or an assignment into an \s-1SQL\s0 integer value.  This value should _not_ be
quoted but rather inserted directly into an \s-1SQL\s0 request.  For example,
if passed \*(L"123\*(R" (a user id), will return \*(L"\s-1CAST\s0('123' \s-1AS UNSIGNED\s0)\*(R"
(same value, quoted);  if passed \*(L"200123456789abcd\*(R" (an encoded \s-1IP\s0),
will return \*(L"\s-1CAST\s0(\s-1CONV\s0('200123456789abcd', 16, 10) \s-1AS UNSIGNED\s0)\*(R" which
can be used as an assignment into or test against a \s-1BIGINT\s0 column.
.PP
For speed, does not do error-checking against the value passed in.
.PP
There are tricky technical reasons why all values that are used in
comparisons to srcid columns must be wrapped in a \s-1CAST\s0(x \s-1AS UNSIGNED\s0).
Tricky enough that I submitted a MySQL bug report which turned out to
be not a bug:  <http://bugs.mysql.com/bug.php?id=24759>.  The short
explanation is that any comparison of a number (the srcid column in
the table) to a string results in both being internally converted to
a float before the comparison, and floats with more bits of data than
will fit in their mantissa do not always compare \*(L"equal to themselves.\*(R"
We must ensure that the values compared against the \s-1BIGINT\s0 column are not
strings, and that means wrapping both a quoted uid ('123' is a string)
and a \s-1CONV\s0 (which returns a string) in a \s-1CAST.\s0  Note that even integers
known to have fewer bits than a float's mantissa, such as uid's, cannot
be quoted strings, as that can break equality testing even for other
properly-CAST values in an \s-1IN\s0 list.
.PP
Usage:
.PP
\&\f(CW$slashdb\fR\->sqlInsert(\*(L"al2\*(R", { srcid => get_srcid_sql_in($srcid) });
.SS "get_srcid_sql_out"
.IX Subsection "get_srcid_sql_out"
Pass this the name of a column with srcid data, and it returns the \s-1SQL\s0
necessary to retrieve data from that column in srcid format.  The
column data is returned in decimal format if it can be represented in
decimal in an ordinarily-compiled perl, as a hex string otherwise.
\&\*(L"Non-decimal characters in the result will be uppercase,\*(R" say the docs,
so we lowercase them.
.PP
Usage:
.PP
\&\f(CW$slashdb\fR\->sqlSelectColArrayref(get_srcid_sql_out('srcid') . ' \s-1AS\s0 srcid',
\&'al2', 'value=1');
.SS "get_srcid_type"
.IX Subsection "get_srcid_type"
Pass this a srcid, either in decimal form (which is what uids will
typically be in) or as a 64\-bit (16\-char) hex string, and it will return
the name of the field in a srcid hashref that the data belongs in: either
\&\*(L"uid\*(R" for a uid, or an integer between 1 and 32 for an encoded \s-1IP.\s0
.PP
For speed, does not do error-checking against the value passed in.
.SS "get_srcid_vis"
.IX Subsection "get_srcid_vis"
Pass this a srcid, either in decimal form (which is what uids will
typically be in) or as a 64\-bit (16\-char) hex string, and it will return
a short text string suitable for display, typically as the text that
is linked in \s-1HTML.\s0
.PP
For speed, does not do error-checking against the value passed in.
.SS "apacheConnectionSSL"
.IX Subsection "apacheConnectionSSL"
Returns true if the current code is running as part of a web request
(as opposed to e.g. from slashd) and if that request was made over
Secure \s-1HTTP\s0 as defined in Slash::Apache.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
\&\fBSlash\fR\|(3), \fBSlash::Utility\fR\|(3).
.SH "POD ERRORS"
.IX Header "POD ERRORS"
Hey! \fBThe above document had some coding errors, which are explained below:\fR
.IP "Around line 3175:" 4
.IX Item "Around line 3175:"
You forgot a '=back' before '=head2'
.IP "Around line 3578:" 4
.IX Item "Around line 3578:"
You forgot a '=back' before '=head2'

.\" Automatically generated by Pod::Man 4.11 (Pod::Simple 3.35)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Display 3"
.TH Display 3 "2020-06-20" "perl v5.26.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Slash::Display \- Display library for Slash
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&        slashDisplay(\*(Aqsome template\*(Aq, { key => $val });
\&        my $text = slashDisplay(\*(Aqtemplate\*(Aq, \e%data, 1);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Slash::Display uses Slash::Display::Provider to provide the
template data from the Slash::DB \s-1API.\s0
.PP
It will process and display a template using the data passed in.
In addition to whatever data is passed in the hashref, the contents
of the user, form, and static objects, as well as the \f(CW%ENV\fR hash,
are available.
.PP
\&\f(CW\*(C`slashDisplay\*(C'\fR will print by default to \s-1STDOUT,\s0 but will
instead return the data if the third parameter is true.  If the fourth
parameter is true, \s-1HTML\s0 comments surrounding the template will \s-1NOT\s0
be printed or returned.  That is, if the fourth parameter is false,
\&\s-1HTML\s0 comments noting the beginning and end of the template will be
printed or returned along with the template.
.PP
Template for more information about templates.
.SH "EXPORTED FUNCTIONS"
.IX Header "EXPORTED FUNCTIONS"
.SS "slashDisplay(\s-1NAME\s0 [, \s-1DATA, OPTIONS\s0])"
.IX Subsection "slashDisplay(NAME [, DATA, OPTIONS])"
Processes a template.
.IP "Parameters" 4
.IX Item "Parameters"
.RS 4
.PD 0
.IP "\s-1NAME\s0" 4
.IX Item "NAME"
.PD
Can be either the name of a template block in the Slash \s-1DB,\s0
or a reference to a scalar containing a template to be
processed.  In both cases, the template will be compiled
and the processed, unless it has previously been compiled,
in which case the cached, compiled template will be pulled
out and processed.
.IP "\s-1DATA\s0" 4
.IX Item "DATA"
Hashref of additional parameters to pass to the template.
Default passed parameters include constants, env, user, anon,
and form.  These cannot be overriden.
.IP "\s-1OPTIONS\s0" 4
.IX Item "OPTIONS"
Hashref of options.  Currently supported options are below.
If \s-1OPTIONS\s0 is the value \f(CW1\fR instead of a hashref, that will
be the same as if the hashref were \f(CW\*(C`{ Return => 1 }\*(C'\fR.
.RS 4
.IP "Return" 4
.IX Item "Return"
Boolean for whether to print (false) or return (true) the
processed template data.  Default is print.
.IP "Nocomm" 4
.IX Item "Nocomm"
Boolean for whether to include (false) or not include (true)
\&\s-1HTML\s0 comments surrounding template, stating what template
block this is.  Default is to include comments if the var
\&\*(L"template_show_comments\*(R" is true, to not include comments
if it is false.  It is true by default.
.Sp
If the var \*(L"template_show_comments\*(R" is greater than 1,
the Nocomm boolean will be ignored and the \s-1HTML\s0 comments
will \s-1ALWAYS\s0 be inserted around templates (except when they
are invoked from within other templates by \s-1INCLUDE\s0 or
\&\s-1PROCESS\s0).  This is \s-1NOT\s0 what you want for a public site, since
(for example) email built up from templates will have \s-1HTML\s0
comments in it which will confuse your readers;  \s-1HTML\s0 tags
built from several templates may have \s-1HTML\s0 comments \*(L"inside\*(R"
them, breaking your \s-1HTML\s0 syntax;  etc.
.IP "Skin" 4
.IX Item "Skin"
Each template is assigned to a skin.  This skin may be
a skin defined as a site skin, or some arbitrary skin
name.  By default, the skin that is used is whatever skin
the user is in, but it can be overridden by setting this parameter.
If a template in the current skin is not found, it defaults
to skin \*(L"default\*(R".
.Sp
Skin will also default first to \*(L"light\*(R" if the user is in light
mode (and fall back to \*(L"default,\*(R" again, if no template for the
\&\*(L"light\*(R" skin exists).
.Sp
A Skin value of \*(L"\s-1NONE\*(R"\s0 will cause no skin to be defined, so
\&\*(L"default\*(R" will be used.
.IP "Page" 4
.IX Item "Page"
Similarly to skins, each template is assigned to a page.
This page may be a page defined in the site, or some arbitrary
page name.  By default, the page that is used is whatever page
the user is on (such as \*(L"users\*(R" for \*(L"users.pl\*(R"), but it can be
overridden by setting this parameter.  If a template in the current
page is not found, it defaults to page \*(L"misc\*(R".
.Sp
A Page value of \*(L"\s-1NONE\*(R"\s0 will cause no page to be defined, so
\&\*(L"misc\*(R" will be used.
.RE
.RS 4
.RE
.RE
.RS 4
.RE
.IP "Return value" 4
.IX Item "Return value"
If \s-1OPTIONS\-\s0>{Return} is true, the processed template data.
Otherwise, returns true/false for success/failure.
.IP "Side effects" 4
.IX Item "Side effects"
Compiles templates and caches them.
.SH "NON-EXPORTED FUNCTIONS"
.IX Header "NON-EXPORTED FUNCTIONS"
.SS "get_template(\s-1CONFIG1, CONFIG2\s0)"
.IX Subsection "get_template(CONFIG1, CONFIG2)"
Return a Template object.
.IP "Parameters" 4
.IX Item "Parameters"
.RS 4
.PD 0
.IP "\s-1CONFIG1\s0" 4
.IX Item "CONFIG1"
.PD
A hashref of options to pass to Template\->new
(will override any defaults).
.IP "\s-1CONFIG2\s0" 4
.IX Item "CONFIG2"
A hashref of options to pass to Slash::Display::Provider\->new
(will override any defaults).
.RE
.RS 4
.RE
.IP "Return value" 4
.IX Item "Return value"
A Template object.  See \*(L"\s-1TEMPLATE ENVIRONMENT\*(R"\s0.
.SH "TEMPLATE ENVIRONMENT"
.IX Header "TEMPLATE ENVIRONMENT"
.SS "Preferences"
.IX Subsection "Preferences"
The template has the options \s-1PRE_CHOMP\s0 and \s-1POST_CHOMP\s0 set by default.
You can change these in the \fBvars\fR table in your database
(template_pre_chomp, template_post_chomp).  Also
look at the template_cache_size variable for setting the cache size.
Template for more information.  The cache will be disabled entirely if
cache_enabled is false.
.SS "Plugin"
.IX Subsection "Plugin"
The template provider is Slash::Display::Provider, and the plugin module
Slash::Display::Plugin can be referenced by simply \*(L"Slash\*(R".
.SS "Additional Ops"
.IX Subsection "Additional Ops"
Additional scalar ops (which are global, so they are in effect
for every Template object created, from this or any other module)
include \f(CW\*(C`int\*(C'\fR, \f(CW\*(C`abs\*(C'\fR, \f(CW\*(C`uc\*(C'\fR, \f(CW\*(C`lc\*(C'\fR, \f(CW\*(C`ucfirst\*(C'\fR, and \f(CW\*(C`lcfirst\*(C'\fR,
which all do what you think.
.PP
.Vb 1
\&        [% myscalar.uc %]  # return upper case myscalar
.Ve
.PP
\&\f(CW\*(C`substr\*(C'\fR accepts 1 or 2 args, for the two corresponding forms of the
perl function \f(CW\*(C`substr\*(C'\fR.
.PP
.Vb 2
\&        [% myscalar.substr(2)    # all but first two characters %]
\&        [% myscalar.substr(2, 1) # third character %]
.Ve
.PP
Additional list ops include \f(CW\*(C`rand\*(C'\fR, \f(CW\*(C`lowval\*(C'\fR, \f(CW\*(C`highval\*(C'\fR,
\&\f(CW\*(C`grepn\*(C'\fR and \f(CW\*(C`remove\*(C'\fR.
.PP
\&\f(CW\*(C`rand\*(C'\fR returns a random value from the list.
.PP
.Vb 1
\&        [% mylist.rand %]  # return single random element from mylist
.Ve
.PP
\&\f(CW\*(C`lowval\*(C'\fR, and \f(CW\*(C`highval\*(C'\fR do exacly what they sound like, they return the 
lowest or the highest value in the list.
.PP
\&\f(CW\*(C`grepn\*(C'\fR returns the position of the first occurance of a given value. See 
\&\f(CW\*(C`Slash::Utility::grepn\*(C'\fR.
.PP
\&\f(CW\*(C`remove\*(C'\fR returns the list with all entries matching the given parameter,
removed.
.PP
.Vb 2
\&        [% b = (0, 1, 0, 2, 0, 3, 0, 5);
\&           b.remove(0).join(\*(Aq,\*(Aq) %]             # Outputs: "1,2,3,5"
.Ve
.SS "Additional Filters"
.IX Subsection "Additional Filters"
Also provided are some filters.  The \f(CW\*(C`fixurl\*(C'\fR, \f(CW\*(C`fixparam\*(C'\fR, \f(CW\*(C`fudgeurl\*(C'\fR,
and \f(CW\*(C`strip_*\*(C'\fR filters are just frontends to the functions of those
names in the Slash \s-1API:\s0
.PP
.Vb 3
\&        [% FILTER strip_literal %]
\&                I think that 1 > 2!
\&        [% END %]
.Ve
.PP
See Slash::Utility::Data for a complete list of available \f(CW\*(C`strip_*\*(C'\fR
filters, and descriptions of each.
.PP
Note that [% var | filter %] is a synonym for [% \s-1FILTER\s0 filter; var; \s-1END\s0 %]:
.PP
.Vb 1
\&        <A HREF="[% env.script_name %]?op=[% form.op | fixparam %]">
.Ve
.PP
It might seem simpler to just use the functional form:
.PP
.Vb 2
\&        [% form.something | strip_nohtml      # filter %]
\&        [% Slash.strip_nohtml(form.something) # function %]
.Ve
.PP
But we might make it harder to use the Slash plugin (see
Slash::Display::Plugin) in the future (perhaps only certain seclevs?), so it
is best to stick with the filter, which is most likely faster anyway.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
\&\fBTemplate\fR\|(3), \fBSlash\fR\|(3), \fBSlash::Utility\fR\|(3), \fBSlash::DB\fR\|(3),
\&\fBSlash::Display::Plugin\fR\|(3), \fBSlash::Display::Provider\fR\|(3).
